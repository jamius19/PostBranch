// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: repoqueries.sql

package dao

import (
	"context"
	"database/sql"
	"time"
)

const countRepo = `-- name: CountRepo :one
SELECT COUNT(*)
FROM repo
`

func (q *Queries) CountRepo(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRepo)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRepoByNameOrPath = `-- name: CountRepoByNameOrPath :one
SELECT COUNT(*)
FROM repo rp
         JOIN zfs_pool zp on rp.pool_id = zp.id
WHERE rp.name = ?
   OR zp.path = ?
`

type CountRepoByNameOrPathParams struct {
	Name string
	Path string
}

func (q *Queries) CountRepoByNameOrPath(ctx context.Context, arg CountRepoByNameOrPathParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRepoByNameOrPath, arg.Name, arg.Path)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBranch = `-- name: CreateBranch :one
INSERT INTO branch (name, repo_id, parent_id, dataset_id)
VALUES (?, ?, ?, ?)
RETURNING id, name, repo_id, parent_id, dataset_id, created_at, updated_at
`

type CreateBranchParams struct {
	Name      string
	RepoID    int64
	ParentID  sql.NullInt64
	DatasetID int64
}

func (q *Queries) CreateBranch(ctx context.Context, arg CreateBranchParams) (Branch, error) {
	row := q.db.QueryRowContext(ctx, createBranch,
		arg.Name,
		arg.RepoID,
		arg.ParentID,
		arg.DatasetID,
	)
	var i Branch
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RepoID,
		&i.ParentID,
		&i.DatasetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRepo = `-- name: CreateRepo :one
INSERT INTO repo (name, pool_id)
VALUES (?, ?)
RETURNING id, name, pool_id, created_at, updated_at
`

type CreateRepoParams struct {
	Name   string
	PoolID int64
}

func (q *Queries) CreateRepo(ctx context.Context, arg CreateRepoParams) (Repo, error) {
	row := q.db.QueryRowContext(ctx, createRepo, arg.Name, arg.PoolID)
	var i Repo
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PoolID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRepo = `-- name: GetRepo :one
SELECT rp.id              AS repo_id,
       rp.name            AS repo_name,
       rp.created_at      AS repo_created_at,
       rp.updated_at      AS repo_updated_at,
       zp.id              AS pool_id,
       zp.path            AS pool_path,
       zp.size_in_mb      AS pool_size_in_mb,
       zp.name            AS pool_name,
       zp.mount_path      AS pool_mount_path,
       zp.pool_type       AS pool_type,
       zp.created_at      AS pool_created_at,
       zp.updated_at      AS pool_updated_at,
       pg.id              AS pg_id,
       pg.pg_path         AS pg_path,
       pg.version         AS pg_version,
       pg.status          AS pg_status,
       pg.output          AS pg_output,
       pg.created_at      AS pg_created_at,
       pg.updated_at      AS pg_updated_at
FROM repo rp
         JOIN zfs_pool zp on rp.pool_id = zp.id
         LEFT JOIN main.pg pg on rp.id = pg.repo_id
WHERE rp.id = ?
`

type GetRepoRow struct {
	RepoID        int64
	RepoName      string
	RepoCreatedAt time.Time
	RepoUpdatedAt time.Time
	PoolID        int64
	PoolPath      string
	PoolSizeInMb  int64
	PoolName      string
	PoolMountPath string
	PoolType      string
	PoolCreatedAt time.Time
	PoolUpdatedAt time.Time
	PgID          sql.NullInt64
	PgPath        sql.NullString
	PgVersion     sql.NullInt64
	PgStatus      sql.NullString
	PgOutput      sql.NullString
	PgCreatedAt   sql.NullTime
	PgUpdatedAt   sql.NullTime
}

func (q *Queries) GetRepo(ctx context.Context, id int64) (GetRepoRow, error) {
	row := q.db.QueryRowContext(ctx, getRepo, id)
	var i GetRepoRow
	err := row.Scan(
		&i.RepoID,
		&i.RepoName,
		&i.RepoCreatedAt,
		&i.RepoUpdatedAt,
		&i.PoolID,
		&i.PoolPath,
		&i.PoolSizeInMb,
		&i.PoolName,
		&i.PoolMountPath,
		&i.PoolType,
		&i.PoolCreatedAt,
		&i.PoolUpdatedAt,
		&i.PgID,
		&i.PgPath,
		&i.PgVersion,
		&i.PgStatus,
		&i.PgOutput,
		&i.PgCreatedAt,
		&i.PgUpdatedAt,
	)
	return i, err
}

const listBranchesByRepoId = `-- name: ListBranchesByRepoId :many
SELECT id, name, repo_id, parent_id, dataset_id, created_at, updated_at
FROM branch
WHERE repo_id = ?
`

func (q *Queries) ListBranchesByRepoId(ctx context.Context, repoID int64) ([]Branch, error) {
	rows, err := q.db.QueryContext(ctx, listBranchesByRepoId, repoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Branch
	for rows.Next() {
		var i Branch
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RepoID,
			&i.ParentID,
			&i.DatasetID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepo = `-- name: ListRepo :many
SELECT rp.id              AS repo_id,
       rp.name            AS repo_name,
       rp.created_at      AS repo_created_at,
       rp.updated_at      AS repo_updated_at,
       zp.id              AS pool_id,
       zp.path            AS pool_path,
       zp.size_in_mb      AS pool_size_in_mb,
       zp.name            AS pool_name,
       zp.mount_path      AS pool_mount_path,
       zp.pool_type       AS pool_type,
       zp.created_at      AS pool_created_at,
       zp.updated_at      AS pool_updated_at,
       pg.id              AS pg_id,
       pg.pg_path         AS pg_path,
       pg.version         AS pg_version,
       pg.status          AS pg_status,
       pg.output          AS pg_output,
       pg.created_at      AS pg_created_at,
       pg.updated_at      AS pg_updated_at
FROM repo rp
         JOIN zfs_pool zp on rp.pool_id = zp.id
         LEFT JOIN main.pg pg on rp.id = pg.repo_id
ORDER BY rp.created_at DESC
`

type ListRepoRow struct {
	RepoID        int64
	RepoName      string
	RepoCreatedAt time.Time
	RepoUpdatedAt time.Time
	PoolID        int64
	PoolPath      string
	PoolSizeInMb  int64
	PoolName      string
	PoolMountPath string
	PoolType      string
	PoolCreatedAt time.Time
	PoolUpdatedAt time.Time
	PgID          sql.NullInt64
	PgPath        sql.NullString
	PgVersion     sql.NullInt64
	PgStatus      sql.NullString
	PgOutput      sql.NullString
	PgCreatedAt   sql.NullTime
	PgUpdatedAt   sql.NullTime
}

func (q *Queries) ListRepo(ctx context.Context) ([]ListRepoRow, error) {
	rows, err := q.db.QueryContext(ctx, listRepo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRepoRow
	for rows.Next() {
		var i ListRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.RepoName,
			&i.RepoCreatedAt,
			&i.RepoUpdatedAt,
			&i.PoolID,
			&i.PoolPath,
			&i.PoolSizeInMb,
			&i.PoolName,
			&i.PoolMountPath,
			&i.PoolType,
			&i.PoolCreatedAt,
			&i.PoolUpdatedAt,
			&i.PgID,
			&i.PgPath,
			&i.PgVersion,
			&i.PgStatus,
			&i.PgOutput,
			&i.PgCreatedAt,
			&i.PgUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePgRepo = `-- name: UpdatePgRepo :one
UPDATE pg
SET repo_id    = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, pg_path, version, status, output, repo_id, created_at, updated_at
`

type UpdatePgRepoParams struct {
	RepoID int64
	ID     int64
}

func (q *Queries) UpdatePgRepo(ctx context.Context, arg UpdatePgRepoParams) (Pg, error) {
	row := q.db.QueryRowContext(ctx, updatePgRepo, arg.RepoID, arg.ID)
	var i Pg
	err := row.Scan(
		&i.ID,
		&i.PgPath,
		&i.Version,
		&i.Status,
		&i.Output,
		&i.RepoID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
